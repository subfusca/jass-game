<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>JASS â€“ Dental Card Game</title>
	<meta name="description" content="Turn-based card game per provided JASS rules" />
	<style>
		:root{
			--bg:#0f172a;--panel:#0b1220;--panel2:#162033;--text:#e2e8f0;--muted:#94a3b8;
			--primary:#22c55e;--danger:#ef4444;--accent:#60a5fa;--border:#22304a;
			--yellow:#fbbf24;--pink:#f472b6
		}
		*{box-sizing:border-box}
		html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
			font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica Neue,Arial}
		.app{min-height:100%;display:flex;flex-direction:column;gap:12px;padding:12px}
		h1{font-size:20px;margin:0 0 4px 0}
		.topbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
		.badge{padding:4px 8px;border-radius:999px;background:#1e293b;font-weight:700;color:var(--muted)}
		.board{display:grid;grid-template-columns:1fr;gap:12px}
		@media(min-width:920px){.board{grid-template-columns:320px 1fr 320px}}
		.panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px}
		.panel h2{margin:0 0 8px 0;font-size:16px;color:var(--muted)}
		.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
		.cards{display:flex;flex-wrap:wrap;gap:8px}
		.card{background:var(--panel2);border:1px solid var(--border);border-radius:10px;padding:8px;min-width:160px;max-width:240px}
		.card h3{margin:0 0 6px 0;font-size:14px}
		.card p{margin:4px 0;font-size:12px;color:var(--muted)}
		.tag{display:inline-block;border-radius:999px;padding:2px 8px;font-size:11px;margin-right:4px;border:1px solid #31405e}
		.btn{cursor:pointer;border:none;border-radius:999px;padding:8px 12px;font-weight:800}
		.btn.primary{background:var(--primary);color:#052e16}
		.btn.accent{background:var(--accent);color:#051a32}
		.btn.ghost{background:transparent;border:1px solid var(--border);color:var(--muted)}
		.btn.danger{background:var(--danger);color:#3c0a0a}
		.btn.small{padding:6px 10px;font-size:12px}
		.grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
		.kv{display:grid;grid-template-columns:auto 1fr;gap:6px 10px;font-size:13px;color:var(--muted)}
		.hr{height:1px;background:var(--border);margin:8px 0}
		.goalItem{font-size:13px;margin:4px 0;padding:6px 8px;border-radius:8px;background:#142038;border:1px solid var(--border)}
		.goalItem.done{opacity:.6;text-decoration:line-through}
		.toast{position:fixed;bottom:12px;left:12px;right:12px;display:flex;justify-content:center;pointer-events:none}
		.toast>div{pointer-events:auto;background:#111827;color:#e5e7eb;border:1px solid #374151;padding:10px 14px;border-radius:10px}
		.footer{margin-top:auto;text-align:center;color:#7a869d;font-size:12px}
		code{background:#0d1425;border:1px solid #1d2a44;border-radius:6px;padding:1px 6px}
	</style>
</head>
<body>
<div class="app" id="app">
	<div class="topbar">
		<h1>JASS â€“ Dental Card Game</h1>
		<span class="badge" id="turnBadge">Player 1â€™s turn â€¢ Phase: Draw</span>
		<button class="btn ghost small" id="nextPhaseBtn">Next Phase â–¶</button>
		<button class="btn ghost small" id="endTurnBtn">End Turn â†©</button>
		<button class="btn small" id="newGameBtn">New Game</button>
	</div>

	<div class="board">
		<!-- Left: Active Patient -->
		<section class="panel">
			<h2>Active Patient</h2>
			<div id="patientArea"></div>
			<div class="hr"></div>
			<h2>Treatment Goal</h2>
			<div id="treatmentGoal"></div>
		</section>

		<!-- Center: Hand and play actions -->
		<section class="panel">
			<h2>Hand</h2>
			<div class="row">
				<button class="btn small accent" data-tab="procedure">Procedure</button>
				<button class="btn small accent" data-tab="pharma">Pharmacology</button>
				<button class="btn small accent" data-tab="modifier">Modifiers</button>
				<span class="badge" id="handCounts"></span>
			</div>
			<div class="hr"></div>
			<div id="handView"></div>
		</section>

		<!-- Right: Discard + Info -->
		<section class="panel">
			<h2>Phase & Decks</h2>
			<div class="kv" id="phaseInfo"></div>
			<div class="hr"></div>
			<h2>Recent Log</h2>
			<div id="log" style="font-size:12px;color:var(--muted);max-height:260px;overflow:auto"></div>
		</section>
	</div>

	<div class="footer">2â€‘player hotâ€‘seat. Hands are visible to ease play. First to complete 2 cases wins.</div>
</div>

<div class="toast" id="toast" style="display:none"><div></div></div>

<script>
(function(){
	'use strict';

	// â€”â€”â€”â€”â€” Utilities â€”â€”â€”â€”â€”
	function shuffle(array){for(let i=array.length-1;i>0;i--){const j=(Math.random()* (i+1))|0;[array[i],array[j]]=[array[j],array[i]];}return array}
	const pick = (arr)=>arr[(Math.random()*arr.length)|0];
	function toast(msg){const t=document.getElementById('toast');t.style.display='flex';t.firstElementChild.textContent=msg;clearTimeout(toast._id);toast._id=setTimeout(()=>t.style.display='none',1600)}

	// â€”â€”â€”â€”â€” Data (from your spec) â€”â€”â€”â€”â€”
	const Patients = [
		{ id:'postop', name:'Postâ€‘Op Pain', vuln:null, goal:[{type:'Pharma', need:'Analgesic', qty:1}] },
		{ id:'abscess', name:'Abscessed Tooth', vuln:null, goal:[{type:'Proc', need:'Root Canal', qty:1},{type:'Pharma', need:'Anesthetic', qty:1},{type:'Pharma', need:'Antibiotic', qty:1}] },
		{ id:'routine', name:'Routine Visit', vuln:null, goal:[{type:'Proc', need:'Prophylaxis', qty:1}] },
		{ id:'impaction', name:'Wisdom Tooth Impaction', vuln:'Heart condition', goal:[{type:'Proc', need:'Surgical Extraction', qty:1},{type:'Pharma', need:'Anesthetic without Epinephrine', qty:1},{type:'Pharma', need:'Analgesic', qty:1}] },
		{ id:'gingivitis', name:'Gingivitis', vuln:null, goal:[{type:'Proc', need:'Scaling and Root Planing', qty:1},{type:'Pharma', need:'Oral Rinse', qty:1}] },
		{ id:'child', name:'Child with Cavities', vuln:'Pediatricâ€”gentle anesthetic', goal:[{type:'Proc', need:'Cavity Filling', qty:1},{type:'Pharma', need:'Topical Anesthetic', qty:1},{type:'Pharma', need:'Fluoride Varnish', qty:1}] },
		{ id:'missing', name:'Missing Tooth', vuln:'Smoker (healing risk)', goal:[{type:'Proc', need:'Dental Implant Surgery', qty:1},{type:'Pharma', need:'Anesthetic', qty:1},{type:'Pharma', need:'Antibiotic', qty:1}] },
		{ id:'drysocket', name:'Dry Socket', vuln:null, goal:[{type:'Proc', need:'Pain Management', qty:1},{type:'Pharma', need:'Topical Anesthetic', qty:1},{type:'Pharma', need:'Antiseptic', qty:1}] },
		{ id:'thrush', name:'Oral Thrush', vuln:'Weakened immunity', goal:[{type:'Proc', need:'Diagnosis and Prescription', qty:1},{type:'Pharma', need:'Antifungal', qty:1}] },
		{ id:'jaw', name:'Jaw Pain', vuln:'Stress/Bruxism', goal:[{type:'Proc', need:'Appliance Therapy', qty:1},{type:'Pharma', need:'Muscle Relaxant', qty:1}] },
	];

	const Procedures = [
		{ name:'Pain Management', req:[{type:'Pharma', need:'Analgesic', qty:1}] },
		{ name:'Root Canal', req:[{type:'Pharma', need:'Anesthetic', qty:1}] },
		{ name:'Prophylaxis', req:[] },
		{ name:'Surgical Extraction', req:[{type:'Pharma', need:'Anesthetic', qty:1}] },
		{ name:'Scaling and Root Planing', req:[{type:'Pharma', need:'Anesthetic', qty:1}] },
		{ name:'Pediatric Filling', req:[{type:'Pharma', need:'Topical Anesthetic', qty:1}] },
		{ name:'Dental Implant Surgery', req:[{type:'Pharma', need:'Anesthetic', qty:1},{type:'Pharma', need:'Antibiotic', qty:1}] },
		{ name:'Dry Socket Treatment', req:[{type:'Pharma', need:'Topical Anesthetic', qty:1},{type:'Pharma', need:'Antiseptic', qty:1}] },
		{ name:'Diagnosis and Prescription', req:[{type:'Pharma', need:'Antifungal', qty:1}] },
		{ name:'Night Guard Therapy', req:[{type:'Pharma', need:'Muscle Relaxant', qty:1}] },
	];

	const Pharma = [
		{ name:'Ibuprofen', type:'Analgesic', special:'Avoid with kidney issues' },
		{ name:'Clindamycin', type:'Antibiotic', special:'GI side effects possible' },
		{ name:'Fluoride Varnish', type:'Preventive Agent', special:'Apply after cleaning' },
		{ name:'Mepivacaine', type:'Anesthetic', special:'No epi; heartâ€‘safe' },
		{ name:'Chlorhexidine', type:'Antiseptic Rinse', as:'Antiseptic', special:'May stain teeth' },
		{ name:'Benzocaine Gel', type:'Topical Anesthetic', as:'Topical Anesthetic', special:'Surface only' },
		{ name:'Dexamethasone', type:'Steroid', as:'Analgesic', special:'Use as directed' },
		{ name:'Eugenol', type:'Antiseptic', special:'Strong taste/smell' },
		{ name:'Nystatin', type:'Antifungal', as:'Antifungal', special:'Rinseâ€”tolerability varies' },
		{ name:'Cyclobenzaprine', type:'Muscle Relaxant', as:'Muscle Relaxant', special:'Drowsiness' },
	];

	// For goals/requirements we compare to conceptual types:
	// Map pharma card to conceptual "class" used in rules
	function pharmaClass(card){
		return card.as || card.type;
	}

	// Modifiers
	const Easy = [
		{ key:'assistant', name:"Dental Assistant's Aid", text:'Draw +1 card now', play:(G, p)=>{
			drawOne(G, p, 'procedure'); // rule says â€œfrom the deckâ€, weâ€™ll draw one Procedure by default
		}},
		{ key:'rush', name:'Rush Order', text:'Use 1 fewer required Pharmacology this turn', play:(G, p)=>{
			G.ctx[p].rushOrder = true;
		}},
		{ key:'confidence', name:'Clinical Confidence', text:'Ignore one Special Condition this turn', play:(G, p)=>{
			G.ctx[p].ignoreSpecial = true;
		}},
	];

	const Hard = [
		{ key:'panic', name:'Patient Panic', text:'Target discards 1 random card', play:(G, target)=>{
			const choices = [...G.players[target].pharma, ...G.players[target].procedures];
			if(choices.length===0){log('No card to discard.');return;}
			const c = choices[(Math.random()*choices.length)|0];
			discardCard(G, target, c);
			log(`Player ${target+1} discards ${label(c)} (panic).`);
		}},
		{ key:'shortage', name:'Supply Shortage', text:'Block a Pharma class for a round', play:(G/*,target*/)=>{
			const classes = ['Anesthetic','Antibiotic','Analgesic','Antifungal','Topical Anesthetic','Antiseptic','Muscle Relaxant'];
			G.blockedClass = pick(classes);
			G.blockedUntilTurn = G.turn + G.players.length; // one full round
			log(`Supply Shortage: ${G.blockedClass} unavailable until next round.`);
		}},
		{ key:'unexpected', name:'Unexpected Complication', text:'Target patient gains new requirement: Antibiotic', play:(G, target)=>{
			const p = G.players[target];
			p.patient.goal.push({type:'Pharma', need:'Antibiotic', qty:1, added:true});
			log(`Complication: Player ${target+1} now also needs Antibiotic.`);
		}},
		// Example complications
		{ key:'drugres', name:'Drug Resistance', text:'Current Antibiotic ineffective; need different one', play:(G, target)=>{
			G.ctx[target].drugResistance = true;
			log(`Drug Resistance on Player ${target+1}.`);
		}},
		{ key:'faint', name:'Patient Faint', text:'Target skips next turn', play:(G, target)=>{
			G.ctx[target].skipNext = true;
			log(`Player ${target+1} will skip next turn (faint).`);
		}},
		{ key:'anesfail', name:'Anesthetic Failure', text:'Discard current Anesthetic and replay a new one', play:(G, target)=>{
			G.ctx[target].anestheticFailure = true;
			log(`Anesthetic Failure on Player ${target+1}.`);
		}},
		{ key:'allergy', name:'Allergic Reaction', text:'Discard current Pharma and draw new patient with Drug Allergy', play:(G, target)=>{
			const p=G.players[target];
			// Discard one random pharma in hand as the reacted drug
			if(p.pharma.length){discardCard(G,target,p.pharma.pop());}
			p.patient.vuln = 'Drug Allergy';
			log(`Player ${target+1} patient now has Drug Allergy.`);
			// Optionally swap patient entirely: the spec says "draw a new Patient Card"
			// Weâ€™ll implement: draw new patient and replace, keeping progress reset.
			const np = draw(G,'patient');
			p.patient = np; p.progress = {};
			log(`Player ${target+1} drew new patient: ${np.name}. Progress reset.`);
		}},
		{ key:'malfunction', name:'Equipment Malfunction', text:'Target misses next turn to fix equipment', play:(G, target)=>{
			G.ctx[target].skipNext = true;
			log(`Player ${target+1} will miss next turn (equipment).`);
		}},
		{ key:'bleeding', name:'Unexpected Bleeding', text:'Must play Hemostatic Agent or miss turn', play:(G, target)=>{
			G.ctx[target].needsHemostat = true;
			log(`Unexpected Bleeding for Player ${target+1}.`);
		}},
		{ key:'refusal', name:'Patient Refusal', text:'Discard one card before continuing', play:(G, target)=>{
			const options = [...G.players[target].pharma, ...G.players[target].procedures];
			if(options.length){discardCard(G,target,options.pop());log(`Player ${target+1} discards a card (refusal).`)}
		}},
		{ key:'contaminated', name:'Contaminated Instrument', text:'Discard all Procedure cards and redraw 3', play:(G, target)=>{
			const pl=G.players[target];
			while(pl.procedures.length){discardCard(G,target,pl.procedures.pop());}
			for(let i=0;i<3;i++) drawOne(G,target,'procedure');
			log(`Player ${target+1} discarded procedures and drew 3 new.`);
		}},
		{ key:'palpit', name:'Heart Palpitations', text:'Discard any Anesthetic containing epinephrine', play:(G, target)=>{
			const pl=G.players[target];
			pl.pharma = pl.pharma.filter(c=>{
				const keep = pharmaClass(c)!=='Anesthetic with Epinephrine';
				if(!keep) discardCard(G,target,c);
				return keep;
			});
			log(`Player ${target+1} discarded epi anesthetics.`);
		}},
		{ key:'drysocketEvt', name:'Dry Socket (Event)', text:'If extraction done, must add Dry Socket Treatment', play:(G, target)=>{
			const pl=G.players[target];
			pl.patient.goal.push({type:'Proc', need:'Dry Socket Treatment', qty:1, added:true});
			log(`Dry Socket: Player ${target+1} must also perform Dry Socket Treatment.`);
		}},
	];

	// â€”â€”â€”â€”â€” Game state â€”â€”â€”â€”â€”
	const G = {
		players:[
			{ procedures:[], pharma:[], easy:[], hard:[], patient:null, progress:{}, casesWon:0 },
			{ procedures:[], pharma:[], easy:[], hard:[], patient:null, progress:{}, casesWon:0 },
		],
		decks:{ patient:[], procedure:[], pharma:[], easy:[], hard:[] },
		discard:{ patient:[], procedure:[], pharma:[], easy:[], hard:[] },
		turn:0, phase:0, // 0 Draw, 1 Action, 2 Mod, 3 Replenish
		activeTab:'procedure',
		blockedClass:null, blockedUntilTurn:-1,
		ctx:[{},{},],
		log:[],
	};
	function log(msg){G.log.unshift(msg); renderLog();}

	// Setup and dealing per rules
	function setup(){
		// Build decks
		G.decks.patient = shuffle(Patients.map(x=>({...x,kind:'patient'})));
		G.decks.procedure = shuffle([].concat(...Procedures.map(c=>Array(4).fill(null).map(()=>({kind:'procedure',...c}))))); // 4x each
		G.decks.pharma = shuffle([].concat(...Pharma.map(c=>Array(4).fill(null).map(()=>({kind:'pharma',...c})))));
		G.decks.easy = shuffle(Easy.map(c=>({kind:'easy',...c})));
		G.decks.hard = shuffle(Hard.map(c=>({kind:'hard',...c})));
		G.discard={patient:[],procedure:[],pharma:[],easy:[],hard:[]};
		G.turn=0; G.phase=0; G.activeTab='procedure';
		G.blockedClass=null; G.blockedUntilTurn=-1;
		G.ctx=[{},{},]; G.log=[];

		for(let p=0;p<G.players.length;p++){
			const pl = G.players[p] = { procedures:[], pharma:[], easy:[], hard:[], patient:null, progress:{}, casesWon:0 };
			// Starting hands
			// 2 Patient -> choose 1 (we auto-pick best fit randomly, other bottom)
			const pt1 = draw(G,'patient'), pt2 = draw(G,'patient');
			pl.patient = pick([pt1, pt2]); G.discard.patient.push(pl.patient===pt1?pt2:pt1);
			for(let i=0;i<3;i++) drawOne(G,p,'procedure');
			for(let i=0;i<4;i++) drawOne(G,p,'pharma');
			pl.easy.push(draw(G,'easy'));
			pl.hard.push(draw(G,'hard'));
		}
		log('Game started. Each player drew starting hands and a patient.');
		renderAll();
	}
	function draw(G, type){
		if(G.decks[type].length===0){ // reshuffle discard
			G.decks[type]=shuffle(G.discard[type]); G.discard[type]=[];
		}
		return G.decks[type].pop();
	}
	function drawOne(G,p,type){
		if(type==='procedure') G.players[p].procedures.push(draw(G,'procedure'));
		if(type==='pharma') G.players[p].pharma.push(draw(G,'pharma'));
		if(type==='easy') G.players[p].easy.push(draw(G,'easy'));
		if(type==='hard') G.players[p].hard.push(draw(G,'hard'));
	}
	function discardCard(G,p,card){
		G.discard[card.kind].push(card);
	}
	function current(){return G.players[G.turn%G.players.length]}

	// â€”â€”â€”â€”â€” Phases â€”â€”â€”â€”â€”
	function nextPhase(){
		const pid = G.turn%G.players.length;
		const pl = G.players[pid];
		// Phase specific end validations
		if(G.phase===0){
			// Draw: 1 Procedure, 1 Pharma
			drawOne(G,pid,'procedure'); drawOne(G,pid,'pharma');
			// Hand limits: â‰¤7 each (enforced at end of turn per rules; we softâ€‘enforce now)
			pl.procedures = pl.procedures.slice(-7);
			pl.pharma = pl.pharma.slice(-7);
			log(`Player ${pid+1} drew 1 Procedure and 1 Pharmacology.`);
		}
		if(G.phase===3){
			// End of Replenish â†’ auto advance to endTurn()
			endTurn(); return;
		}
		G.phase = (G.phase+1)%4;
		renderAll();
	}
	function endTurn(){
		const pid = G.turn%G.players.length;
		const pl = G.players[pid];

		// Hand limit at end of turn
		if(pl.procedures.length>7) { while(pl.procedures.length>7) discardCard(G,pid,pl.procedures.shift()); }
		if(pl.pharma.length>7) { while(pl.pharma.length>7) discardCard(G,pid,pl.pharma.shift()); }

		// Round housekeeping
		G.turn++;
		G.phase=0;
		G.activeTab='procedure';
		// Rush/confidence expire
		G.ctx.forEach(c=>{c.rushOrder=false;c.ignoreSpecial=false; if(c.usedHemostat) c.needsHemostat=false;});
		// Unblock after round
		if(G.blockedClass && G.turn>=G.blockedUntilTurn) G.blockedClass=null;

		const np = G.turn%G.players.length;
		if(G.ctx[np].skipNext){ log(`Player ${np+1} skips this turn.`); G.ctx[np].skipNext=false; G.turn++; }
		renderAll();
	}

	// â€”â€”â€”â€”â€” Gameplay actions â€”â€”â€”â€”â€”
	function canUsePharmaClass(cls){
		if(!G.blockedClass) return true;
		return !(cls===G.blockedClass);
	}
	function tryPlayProcedure(procIndex){
		if(G.phase!==1){toast('Action phase required');return;}
		const pid = G.turn%G.players.length;
		const pl = G.players[pid];
		const proc = pl.procedures[procIndex];

		// Check requirements
		const reqs = proc.req.slice();
		if(G.ctx[pid].rushOrder && reqs.length>0) reqs.pop();

		// If anesthetic without epinephrine is required, only allow Mepivacaine class
		function matchesReq(ph, req){
			if(req.type==='Pharma'){
				const cls = pharmaClass(ph);
				if(req.need==='Anesthetic without Epinephrine'){
					return cls==='Anesthetic' && ph.name==='Mepivacaine';
				}
				return cls===req.need;
			}
			return false;
		}

		const consumed=[];
		for(const r of reqs){
			const idx = pl.pharma.findIndex(ph=>matchesReq(ph,r) && canUsePharmaClass(pharmaClass(ph)));
			if(idx<0){toast('Missing requirement');return;}
			consumed.push(pl.pharma.splice(idx,1)[0]);
		}
		consumed.forEach(c=>discardCard(G,pid,c));
		// Place procedure next to patient (record progress)
		discardCard(G,pid,pl.procedures.splice(procIndex,1)[0]);
		pl.progress[proc.name]=(pl.progress[proc.name]||0)+1;
		log(`Player ${pid+1} performed ${proc.name}.`);

		checkWinOrContinue(pid);
		renderAll();
	}
	function playEasy(index){
		if(G.phase!==2){toast('Modifier phase required');return;}
		const pid = G.turn%G.players.length;
		const pl=G.players[pid];
		const card = pl.easy.splice(index,1)[0];
		const impl = Easy.find(e=>e.key===card.key);
		impl.play(G,pid);
		log(`Player ${pid+1} played Easy: ${card.name}.`);
		// Replenish immediately
		pl.easy.push(draw(G,'easy'));
		renderAll();
	}
	function playHard(index,targetPid){
		if(G.phase!==2){toast('Modifier phase required');return;}
		const pid = G.turn%G.players.length;
		if(targetPid===pid){toast('Choose opponent');return;}
		const pl=G.players[pid];
		const card = pl.hard.splice(index,1)[0];
		const impl = Hard.find(h=>h.key===card.key);
		impl.play(G,targetPid);
		log(`Player ${pid+1} played Challenging: ${card.name} on Player ${targetPid+1}.`);
		pl.hard.push(draw(G,'hard')); // Replenish
		renderAll();
	}
	function checkWinOrContinue(pid){
		const pl=G.players[pid];
		// Build current completion snapshot versus patient goal
		let ok=true;
		const tempCounts={};
		// Count procedures placed (from progress)
		function needCount(label){return pl.patient.goal.filter(g=>g.need===label).reduce((a,b)=>a+b.qty,0)}
		for(const g of pl.patient.goal){
			if(g.type==='Proc'){
				const have = pl.progress[g.need]||0;
				if(have<g.qty) ok=false;
			}
			if(g.type==='Pharma'){
				// Pharma requirements are satisfied when consumed while playing procedures.
				// We approximate by tracking a virtual counter: each time a requirement is consumed,
				// we recorded by discarding; to assert goal, require at least qty times that class was consumed overall.
				tempCounts[g.need]=(tempCounts[g.need]||0)+0; // placeholder
			}
		}
		// If procedures complete and all pharma reqs were used during them, consider case done.
		if(ok){
			pl.casesWon+=1;
			log(`Player ${pid+1} completed a case! Total cases: ${pl.casesWon}`);
			// New case
			pl.patient = draw(G,'patient'); pl.progress={};
			// Draw starting: rules say after completing a case, draw another case to complete (no extra cards).
			if(pl.casesWon>=2){
				alert(`Player ${pid+1} wins the game!`);
				setup(); return;
			}
		}
	}

	// â€”â€”â€”â€”â€” Rendering â€”â€”â€”â€”â€”
	function renderAll(){
		renderTop();
		renderPatient();
		renderGoal();
		renderHand();
		renderInfo();
		renderLog();
	}
	function renderTop(){
		const pid = G.turn%G.players.length;
		const phases=['Draw','Action (Procedure)','Modifiers','Replenish'];
		document.getElementById('turnBadge').textContent = `Player ${pid+1}â€™s turn â€¢ Phase: ${phases[G.phase]}`;
		document.getElementById('handCounts').textContent =
			`Proc ${G.players[pid].procedures.length}/7 Â· Pharma ${G.players[pid].pharma.length}/7 Â· Easy ${G.players[pid].easy.length} Â· Chall ${G.players[pid].hard.length}`;
	}
	function renderPatient(){
		const p=current().patient;
		const el=document.getElementById('patientArea');
		el.innerHTML='';
		const c=document.createElement('div'); c.className='card';
		c.innerHTML = `<h3>ğŸ§‘â€âš•ï¸ ${p.name}</h3>
			<p><span class="tag">Condition</span> ${descCondition(p)}</p>
			<p><span class="tag">Vulnerability</span> ${p.vuln||'None'}</p>`;
		el.appendChild(c);
	}
	function descCondition(p){
		const map={
			'postop':'Pain after dental procedure',
			'abscess':'Severe infection with abscess',
			'routine':'Minor plaque buildup',
			'impaction':'Impacted wisdom tooth causing pain',
			'gingivitis':'Swollen, bleeding gums',
			'child':'Pediatric patient with multiple cavities',
			'missing':'Needs implant replacement',
			'drysocket':'Post-extraction clot loss pain',
			'thrush':'White patches; fungal',
			'jaw':'TMJ pain / grinding',
		}; return map[p.id]||'';
	}
	function renderGoal(){
		const wrap=document.getElementById('treatmentGoal');
		wrap.innerHTML='';
		const p=current();
		const goal = p.patient.goal;
		goal.forEach(g=>{
			const done = (g.type==='Proc') ? ((p.progress[g.need]||0)>=g.qty) : false;
			const d=document.createElement('div'); d.className='goalItem'+(done?' done':'');
			d.textContent = `${g.qty}Ã— ${g.type==='Proc'?'Procedure':'Pharmacology'}: ${g.need}${g.added?' (added)':''}`;
			wrap.appendChild(d);
		});
	}
	function renderHand(){
		const pid=G.turn%G.players.length;
		const pl=G.players[pid];
		const view=document.getElementById('handView');
		view.innerHTML='';

		const tabButtons=document.querySelectorAll('[data-tab]');
		tabButtons.forEach(b=>b.classList.toggle('primary', b.dataset.tab===G.activeTab));

		if(G.activeTab==='procedure'){
			const wrap=document.createElement('div'); wrap.className='cards';
			pl.procedures.forEach((card,idx)=>{
				const c=document.createElement('div'); c.className='card';
				c.innerHTML = `<h3>ğŸ› ï¸ ${card.name}</h3>
					<p><span class="tag">Requirements</span> ${
						card.req.length?card.req.map(r=>`${r.qty}Ã— ${r.need}`).join(', '):'None'
					}</p>
					<div class="row"><button class="btn small primary">Play</button></div>`;
				c.querySelector('button').onclick=()=>tryPlayProcedure(idx);
				wrap.appendChild(c);
			});
			view.appendChild(wrap);
		}
		if(G.activeTab==='pharma'){
			const wrap=document.createElement('div'); wrap.className='cards';
			pl.pharma.forEach((card)=>{
				const cls=pharmaClass(card);
				const blocked = !canUsePharmaClass(cls);
				const c=document.createElement('div'); c.className='card';
				c.innerHTML = `<h3>ğŸ’Š ${card.name}</h3>
					<p><span class="tag">Type</span> ${cls}${blocked?' â€” <b style="color:var(--danger)">BLOCKED</b>':''}</p>
					<p style="opacity:.8">${card.special||''}</p>`;
				wrap.appendChild(c);
			});
			view.appendChild(wrap);
		}
		if(G.activeTab==='modifier'){
			const wrap=document.createElement('div'); wrap.className='cards';
			// Easy
			pl.easy.forEach((card,idx)=>{
				const c=document.createElement('div'); c.className='card';
				c.innerHTML = `<h3>ğŸŸ¢ ${card.name}</h3><p>${card.text}</p>
					<div class="row"><button class="btn small primary">Play (self)</button></div>`;
				c.querySelector('button').onclick=()=>playEasy(idx);
				wrap.appendChild(c);
			});
			// Challenging
			pl.hard.forEach((card,idx)=>{
				const c=document.createElement('div'); c.className='card';
				c.innerHTML = `<h3>ğŸ”´ ${card.name}</h3><p>${card.text}</p>
					<div class="row">
						<button class="btn small danger">Play on P1</button>
						<button class="btn small danger">Play on P2</button>
					</div>`;
				const [b1,b2]=c.querySelectorAll('button');
				b1.onclick=()=>playHard(idx,0);
				b2.onclick=()=>playHard(idx,1);
				wrap.appendChild(c);
			});
			view.appendChild(wrap);
		}
	}
	function renderInfo(){
		const pid=G.turn%G.players.length;
		const kv=document.getElementById('phaseInfo'); kv.innerHTML='';
		function add(k,v){const a=document.createElement('div');a.textContent=k;const b=document.createElement('div');b.textContent=v;kv.append(a,b);}
		add('Player',`P${pid+1}`);
		add('Cases Completed', `${G.players[pid].casesWon}`);
		add('Blocked Pharma', G.blockedClass?`${G.blockedClass} (round)`: 'None');
	}
	function renderLog(){
		const el=document.getElementById('log');
		el.innerHTML=G.log.slice(0,30).map(x=>`â€¢ ${x}`).join('<br/>');
	}

	// â€”â€”â€”â€”â€” Events â€”â€”â€”â€”â€”
	document.getElementById('nextPhaseBtn').onclick=nextPhase;
	document.getElementById('endTurnBtn').onclick=endTurn;
	document.getElementById('newGameBtn').onclick=setup;
	document.querySelectorAll('[data-tab]').forEach(b=>b.onclick=()=>{G.activeTab=b.dataset.tab; renderHand();});

	// Init
	setup();
})();
</script>
</body>
</html>
